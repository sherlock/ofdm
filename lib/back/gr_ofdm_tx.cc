/* -*- c++ -*- */
/*
 * Copyright 2004 Free Software Foundation, Inc.
 * 
 * This file is part of GNU Radio
 * 
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 * 
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <gr_ofdm_tx.h>
#include <gr_io_signature.h>

#include <string.h>
#include <stdio.h>
#include <complex>
using namespace std;
#define LENGTH_HEAD  400

#include <iostream>
using namespace std;
#define MAX_ZEROPAD_SIZE 2048
#define USB_BLOCK_SIZE  512

static gr_complex _zeropad[MAX_ZEROPAD_SIZE];

/*
 * Create a new instance of howto_square_ff and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
gr_ofdm_tx_sptr gr_make_ofdm_tx(unsigned int MCS, unsigned int inputQ_limit) {
	return gr_ofdm_tx_sptr(new gr_ofdm_tx(MCS, inputQ_limit));
}

/*
 * Specify constraints on number of input and output streams.
 * This info is used to construct the input and output signatures
 * (2nd & 3rd args to gr_block's constructor).  The input and
 * output signatures are used by the runtime system to
 * check that a valid number and type of inputs and outputs
 * are connected to this block.  In this case, we accept
 * only 1 input and 1 output.
 */
/*static const int MIN_IN = 1;	// mininum number of input streams
 static const int MAX_IN = 1;	// maximum number of input streams
 static const int MIN_OUT = 1;	// minimum number of output streams
 static const int MAX_OUT = 1;	// maximum number of output streams
 */

/*
 * The private constructor
 */
gr_ofdm_tx::gr_ofdm_tx(unsigned int MCS, unsigned int inputQ_limit) :
	gr_block("ofdm_tx", gr_make_io_signature(0, 0, 0), gr_make_io_signature(1,
			1, sizeof(gr_complex))) {
	// nothing else required in this example
	d_state = INIT;
	d_inputQ = gr_make_msg_queue(inputQ_limit);
	d_nsamples_written = 0;
	d_dataN = 0;
	d_MCS = MCS;

	d_Nfft = 64;
	d_Nofdm = 80;
	d_Ngi = 16;
	d_Nst = 56;
	d_fft = new gri_fft_complex(d_Nfft, false);

	format_stf();
	format_lft();
	//format_param(d_MCS)
	d_block_size = 128;
	d_npost = 5;
	for (int k=0; k<MAX_ZEROPAD_SIZE; k++)
  		  _zeropad[k] = gr_complex(0,0);

}

/*
 * Our virtual destructor.
 */
gr_ofdm_tx::~gr_ofdm_tx() {
	// nothing else required in this example
}

//format the stf
void gr_ofdm_tx::format_stf() {
	int Ntone = 12;
	float Normalization_num = float(d_Nfft) / sqrt(Ntone) / 64.0;
	unsigned int i;
	gr_complex stf[64] = { complex<float> (0, 0), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0), complex<float> (
					-0.707107, -0.707107), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0), complex<float> (
					-0.707107, -0.707107), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0), complex<float> (
					0.707107, 0.707107), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0), complex<float> (
					0.707107, 0.707107), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0), complex<float> (
					0.707107, 0.707107), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0), complex<float> (
					0.707107, 0.707107), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0), complex<float> (
					0.707107, 0.707107), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0), complex<float> (
					-0.707107, -0.707107), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0), complex<float> (
					0.707107, 0.707107), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0), complex<float> (
					-0.707107, -0.707107), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0), complex<float> (
					-0.707107, -0.707107), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0), complex<float> (
					0.707107, 0.707107), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0) };

	//IFFT
	memcpy(d_fft->get_inbuf(), stf, sizeof(gr_complex) * d_Nfft);

	d_fft->execute();

	memcpy(stf_matrix, d_fft->get_outbuf(), sizeof(gr_complex) * d_Nfft);

	// |64|64|32
	for (i = 0; i < d_Nfft; i++) {
		stf_matrix[i] = stf_matrix[i] * Normalization_num;
		stf_matrix[i + d_Nfft] = stf_matrix[i];
	}
	for (i = 0; i < (d_Nfft / 2); i++)
		stf_matrix[i + 2 * d_Nfft] = stf_matrix[i];
	//cout << "Normal in stf = " << Normalization_num <<endl;
	
	//for(i = 0; i < 160; i++)
	//	cout << stf_matrix[i] << "  ";
	//cout <<endl;
	

}
//format the ltf
void gr_ofdm_tx::format_lft() {
	int Ntone = 56;
	float Normalization_num = float(d_Nfft) / sqrt(Ntone) / 64.0;
	unsigned int i;

	gr_complex ltf[64] = { complex<float> (0, 0), complex<float> (1, 0),
			complex<float> (-1, 0), complex<float> (-1, 0), complex<float> (1,
					0), complex<float> (1, 0), complex<float> (-1, 0), complex<
					float> (1, 0), complex<float> (-1, 0),
			complex<float> (1, 0), complex<float> (-1, 0), complex<float> (-1,
					0), complex<float> (-1, 0), complex<float> (-1, 0),
			complex<float> (-1, 0), complex<float> (1, 0),
			complex<float> (1, 0), complex<float> (-1, 0), complex<float> (-1,
					0), complex<float> (1, 0), complex<float> (-1, 0), complex<
					float> (1, 0), complex<float> (-1, 0),
			complex<float> (1, 0), complex<float> (1, 0),
			complex<float> (1, 0), complex<float> (1, 0),
			complex<float> (-1, 0), complex<float> (-1, 0), complex<float> (0,
					0), complex<float> (0, 0), complex<float> (0, 0), complex<
					float> (0, 0), complex<float> (0, 0),
			complex<float> (0, 0), complex<float> (0, 0),
			complex<float> (1, 0), complex<float> (1, 0),
			complex<float> (1, 0), complex<float> (1, 0),
			complex<float> (-1, 0), complex<float> (-1, 0), complex<float> (1,
					0), complex<float> (1, 0), complex<float> (-1, 0), complex<
					float> (1, 0), complex<float> (-1, 0),
			complex<float> (1, 0), complex<float> (1, 0),
			complex<float> (1, 0), complex<float> (1, 0),
			complex<float> (1, 0), complex<float> (1, 0),
			complex<float> (-1, 0), complex<float> (-1, 0), complex<float> (1,
					0), complex<float> (1, 0), complex<float> (-1, 0), complex<
					float> (1, 0), complex<float> (-1, 0),
			complex<float> (1, 0), complex<float> (1, 0),
			complex<float> (1, 0), complex<float> (1, 0) };
	//IFFT
	memcpy(d_fft->get_inbuf(), ltf, sizeof(gr_complex) * d_Nfft);

	d_fft->execute();

	memcpy(ltf_matrix, d_fft->get_outbuf(), sizeof(gr_complex) * d_Nfft);

	// |32|64|64
	int temp;
	temp = d_Nfft / 2 + d_Nfft;
	for (i = 0; i < d_Nfft; i++) {
		ltf_matrix[i] = ltf_matrix[i] * Normalization_num ;
		ltf_matrix[i + temp] = ltf_matrix[i];
	}
	int temp2;
	temp2 = d_Nfft / 2;
	for (i = 0; i < d_Nfft; i++)
		ltf_matrix[i + temp2] = ltf_matrix[i + temp];

}

void gr_ofdm_tx::crc4(char *info, int len, char * crc) {

	char h[4] = { 0, 0, 1, 1 };
	short crc_n;
	crc_n = 4;
	char h_reg;
	int ii, jj;
	assert(len > crc_n);
	for (ii = 0; ii < crc_n; ii++) {
		crc[ii] = info[ii];
	}
	for (ii = crc_n; ii < len; ii++) {
		h_reg = crc[0];
		for (jj = 0; jj < (crc_n - 1); jj++)
			crc[jj] = crc[jj + 1];
		crc[crc_n - 1] = info[ii];
		if (h_reg) {
			crc[0] = crc[0] ^ h[0];
			crc[1] = crc[1] ^ h[1];
			crc[2] = crc[2] ^ h[2];
			crc[3] = crc[3] ^ h[3];
		}
	}
	for (ii = 0; ii < crc_n; ii++) {
		h_reg = crc[0];
		for (jj = 0; jj < (crc_n - 1); jj++)
			crc[jj] = crc[jj + 1];
		crc[crc_n - 1] = 0;
		if (h_reg) {
			crc[0] = crc[0] ^ h[0];
			crc[1] = crc[1] ^ h[1];
			crc[2] = crc[2] ^ h[2];
			crc[3] = crc[3] ^ h[3];
		}
	}

}

void gr_ofdm_tx::cnv_encd(int input_len, char *in_array, char *out_array) {
	int K = 3; /* polynomials for K = 3 */
	int g[2][3] = { { 1, 1, 1 }, { 1, 0, 1 } }; /* 7 *//* 5 */
	int m; /* K - 1 */
	int t, tt; /* bit time, symbol time */
	int j, k; /* loop variables */
	char *unencoded_data; /* pointer to data array */
	char shift_reg[K]; /* the encoder shift register */
	int sr_head; /* index to the first elt in the sr */
	int p, q; /* the upper and lower xor gate outputs */

	m = 0;

	unencoded_data = in_array;

	/* Initialize the shift register */
	for (j = 0; j < K; j++) {
		shift_reg[j] = 0;
	}

	/* To try to speed things up a little, the shift register will be operated
	 as a circular buffer, so it needs at least a head pointer. It doesn't
	 need a tail pointer, though, since we won't be taking anything out of
	 it--we'll just be overwriting the oldest entry with the new data. */
	sr_head = 0;

	/* initialize the channel symbol output index */
	tt = 0;

	/* Now start the encoding process */
	/* compute the upper and lower mod-two adder outputs, one bit at a time */
	for (t = 0; t < input_len + m; t++) {
		shift_reg[sr_head] = *(unencoded_data + t);
		p = 0;
		q = 0;
		for (j = 0; j < K; j++) {
			k = (j + sr_head) % K;
			p ^= shift_reg[k] & g[0][j];
			q ^= shift_reg[k] & g[1][j];
		}

		/* write the upper and lower xor gate outputs as channel symbols */
		*(out_array + tt) = p;
		tt = tt + 1;
		*(out_array + tt) = q;
		tt = tt + 1;

		sr_head -= 1; /* equivalent to shifting everything right one place */
		if (sr_head < 0) /* but make sure we adjust pointer modulo K */
			//sr_head = m;
			sr_head = K - 1;

	}

	/* free the dynamically allocated array */
	// free(unencoded_data);


}

//modulation_bit(4bits) length_bit(16bits) ext_lft_bit(2bits) crc_bit(4bit)

void gr_ofdm_tx::format_param(unsigned int MCS, unsigned int length_msg,
		int Ntx) {
	//d_param_ofdm[80];
	int ii, jj, kk;
	char crc_bit[4];
	char param[26];
	char encoded_param[52];
	gr_complex* param_Nst;
	param_Nst = &d_param_ofdm[16];

	for (ii = 0; ii < 4; ii++)
		param[ii] = (MCS >> ii) & 1;

	for (ii = 0; ii < 16; ii++)
		param[4 + ii] = (length_msg >> ii) & 1;
	for (ii = 0; ii < 2; ii++)
		param[20 + ii] = ((Ntx-1) >> ii) & 1;

	crc4(param, 22, crc_bit);
	for (ii = 0; ii < 4; ii++)
		param[22 + ii] = crc_bit[ii];
	
		
	//debug
	for(ii = 0; ii < 26; ii++)
		printf("%d  ", param[ii]);
	printf("\n");
	//end
	
	//encoding  g[2][3] = {{1, 1, 1}, {1, 0, 1}};    /* 7 */  /* 5 */
	//Rate = 1/2
	cnv_encd(26, param, encoded_param);
	
	
	//debug
	for(ii = 0; ii < 52; ii++)
		printf("%d  ", encoded_param[ii]);
	printf("\n");
	//end
	

	//BPSK Modulation
	for (ii = 0; ii < 52; ii++)
		encoded_param[ii] = (encoded_param[ii] == 0) ? -1 : 1;

	//Pilot insertion Len 52=>56 
	char pilots[4] = { 1, 1, 1, -1 };
	int pilot_index[4] = { 7, 21, 34, 48 };
	int pilot_dis[6] = { -1, 7, 21, 34, 48, 56 };

	//param_Nst
	for (ii = 0; ii < 4; ii++)
		param_Nst[pilot_index[ii]] = pilots[ii];
	kk = 0;
	for (ii = 0; ii < 5; ii++)
		for (jj = (pilot_dis[ii]+1); jj < pilot_dis[ii + 1]; jj++) {
			param_Nst[jj] = encoded_param[kk];
			kk++;
		}
		
	//for(ii = 0; ii < 56; ii++)
	//	printf("%f  ", param_Nst[ii].real());
	//printf("\n");	
		
		
	//IFFT len 56=>64 insert NULL sub-carriers
	int null_index[8] = { 0, 29, 30, 31, 32, 33, 34, 35 };
	int sub_index[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16,
			17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 36, 37, 38, 39, 40,
			41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
			58, 59, 60, 61, 62, 63 };
	for (ii = 55; ii >= 0; ii--) {
		param_Nst[sub_index[ii]] = param_Nst[ii];
	}

	//IFFT
	memcpy(d_fft->get_inbuf(), param_Nst, sizeof(gr_complex) * d_Nfft);

	d_fft->execute();

	memcpy(param_Nst, d_fft->get_outbuf(), sizeof(gr_complex) * d_Nfft);

	printf("Normatlization \n");
	
	// 16|64 OFDM sym
	float Normalization_num;
	//printf("d_Nfft = %f \n",(float)(d_Nfft));
	//printf("sqrt((float)d_Nst = %f \n",(float)sqrt((float)d_Nst));
	Normalization_num = (float)(d_Nfft) / (float)sqrt((float)d_Nst) / 64.0; 
	printf("Normalization_num = %f \n",Normalization_num);
	for(ii=0; ii<64; ii++)
	{
		param_Nst[ii] = param_Nst[ii] * Normalization_num ;
		//param_Nst[ii].real() = param_Nst[ii].real() * Normalization_num;
		//param_Nst[ii].imag() = param_Nst[ii].imag() * Normalization_num;
		
	}
	//Add CP
	for(ii=0; ii<16; ii++)
		d_param_ofdm[ii] = d_param_ofdm[64+ii];

}

void gr_ofdm_tx::format_data(unsigned int MCS,int Ntx, unsigned int length_msg,unsigned char *msg, gr_complex *out_data_sym)
{
	  int n_crc_bits = 4; 
	  char crc_bit[4];
	  int ii,jj,mm;
	  float Rate_Coding = 1.0/2.0;
	  int Data_Mod = 2; //BPSK
	  int Data_Nsub = 52;
	  int Ndbps; //the number of bits in one OFDM sym
	  Ndbps = Data_Nsub * Rate_Coding * (log((float)Data_Mod)/log(2.0));
	  printf("Ndbps in format = %d \n", Ndbps);
	  int Data_Nsym;
	  int length_msg_bits;
	  int row_holder, col_holder;
	  int Nst, Nsd, Nsp, Nnull;
	  
	  
	  char data_index[] = {0,1,2,3,4,5,6,8,9,10,11,12,13,14,15,16,17,18,19,20,22,23,24,25,26,27,28,29,30,31,32,33,35,36,37,38,39,40,41,42,43,44,45,46,47,49,50,51,52,53,54,55};
	  char p[] = {1,1,1,1,0,0,0,1,0,0,0,0,1,1,0,1,0,0,1,1,0,1,1,0,1,1,1,1,1,1,0,1,1,1,0,1,1,0,0,1,1,1,0,1,0,0,0,1,0,1,0,0,1,0,0,1,1,1,1,1,0,0,1,1,0,0,1,0,1,0,1,1,0,0,0,1,1,0,0,0,0,1,0,0,1,0,1,1,1,1,0,1,0,1,0,1,0,0,0,0,0,1,0,1,1,0,1,0,1,1,1,0,0,1,0,0,0,1,1,1,0,0,0,0,0,0,0};
	  for(ii=0; ii<127; ii++)
	  {
		  p[ii] = p[ii] * 2;
		  p[ii] = p[ii] - 1;
	  }
	  
	  char pilot_index[] = {7, 21, 34, 48};
	  char pilots[] = { 1, 1, 1, 0};
	  for(ii=0; ii<4; ii++)
	  {
		  pilots[ii] *= 2;
		  pilots[ii] -= 1;
	  }
	  int z = 2;
	  gr_complex temp;
	  
	  char sub_index[] = {1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63 } ;
	  char null_index[] = { 0,29,30,31,32,33,34,35};
	  Nnull = 8; //Nofdm - Nst
	  float normalization_constant;
	  
	  
	  Data_Nsym = ceil((float)(length_msg*8 + n_crc_bits) / (float)Ndbps);
	  //int Data_Nsamples;
	  //Data_Nsamples = Data_Nsym * (d_Nfft + d_Ngi);
	  char *msgcrc_bits;
	  char *encoded_msg;
	  //ii =  length_msg_bits + n_crc_bits;
	  length_msg_bits = Data_Nsym*Ndbps;
	  msgcrc_bits = (char *) malloc(sizeof(char) * length_msg_bits);
	  encoded_msg = (char *) malloc((sizeof(char) * length_msg_bits * 2));
	  
	  for(ii=0; ii<length_msg; ii++)
		  for(jj=0; jj<8; jj++)
			  msgcrc_bits[ii*8+jj] = (msg[ii]>>jj)&1;
	  //compute the crc
	  crc4(msgcrc_bits, length_msg*8, crc_bit);
	  for(ii=0; ii<4; ii++)
		  msgcrc_bits[length_msg*8+ii] = crc_bit[ii];
	  for(ii=(length_msg*8+4); ii<length_msg_bits; ii++)
		  msgcrc_bits[ii] = 0;
	  
	  printf("pad num = %d", (length_msg_bits - (length_msg*8+4)))	;
	  //encoding  g[2][3] = {{1, 1, 1}, {1, 0, 1}};    /* 7 */  /* 5 */
	  //Rate = 1/2
	  cnv_encd(length_msg_bits, msgcrc_bits, encoded_msg);
	  
	  //BPSK Modulation
	  if(Data_Mod == 2)
	  {
		  for(ii=0; ii<( length_msg_bits * 2); ii++)
			  out_data_sym[ii] = (encoded_msg[ii] == 0)? -1 : 1;
	  }
	  //Add pilots
	  Nst = 56;
	  Nsd = 52;
	  Nsp = 4;
	  for(ii=Data_Nsym-1; ii>=0; ii--)
	  {
		  row_holder = ii * Nst;
		  col_holder = ii * Nsd;
		  for(jj=Nsd-1; jj>=0; jj--)
		  {
			  temp = out_data_sym[row_holder+(int)data_index[jj]];
			  out_data_sym[row_holder+(int)data_index[jj]] = 
					  out_data_sym[col_holder+jj];
			  out_data_sym[col_holder+jj] = temp;
		  }
		  for(jj=Nsp; jj>=0; jj--)
		  {
			  out_data_sym[row_holder+(int)(pilot_index[jj])] = p[(ii+z)%127];
			  out_data_sym[row_holder+(int)(pilot_index[jj])] *= pilots[((ii+jj)%Nsp)];
			  
		  }
	  }
	  
	  //IFFT and Add cp
	  for(ii=Data_Nsym-1; ii>=0; ii--)
	  {
		  row_holder = d_Nofdm*ii + d_Ngi;
		  col_holder = ii*Nst;
		  for(jj=Nst-1; jj>=0; jj--)
			  out_data_sym[row_holder + (int) (sub_index[jj])]
					= out_data_sym[col_holder + jj];
		for (jj = Nnull - 1; jj >= 0; jj--)
			out_data_sym[row_holder + (int) (null_index[jj])] = 0;

	}

	//take IFFT
	normalization_constant = (float(d_Nfft) / sqrt(Nst)) / 64.0;
	for (ii = 0; ii < Data_Nsym ; ii++) {
		row_holder = ii*d_Nofdm + d_Ngi;
		//IFFT
		memcpy(d_fft->get_inbuf(), &out_data_sym[row_holder], sizeof(gr_complex) * d_Nfft);

		d_fft->execute();

		memcpy(&out_data_sym[row_holder], d_fft->get_outbuf(), sizeof(gr_complex) * d_Nfft);
		
		for(jj=row_holder; jj<((ii+1)*d_Nofdm); jj++)
		{
			out_data_sym[jj].real() = out_data_sym[jj].real() * normalization_constant;
			out_data_sym[jj].imag() = out_data_sym[jj].imag() * normalization_constant;
		}
		

	}
	
	for(ii=Data_Nsym-1; ii>=0; ii--)
	{
		row_holder = ii*d_Nofdm;
		col_holder = ii*d_Nofdm + d_Nfft;
		for(jj=0; jj<d_Ngi; jj++)
			out_data_sym[row_holder+jj] = out_data_sym[(col_holder+jj)];
	}
	
	
		
	
	  

}


int gr_ofdm_tx::general_work(int noutput_items, gr_vector_int &ninput_items,
		gr_vector_const_void_star &input_items,
		gr_vector_void_star &output_items) {
	gr_complex* out = (gr_complex *) output_items[0];
	gr_complex* in = NULL;
	int incout = 0;
	int nout = 0;
	int msg_length;
//	int i;
	
	//compute for the data 
	int n_crc_bits = 4;
	float Rate_Coding = 1.0 / 2.0;
	int Data_Mod = 2; //BPSK
	int Data_Nsub = 52;
	int Ndbps; //the number of bits in one OFDM sym
	int Data_Nsym;
	int Data_Nsamples;
	
	gr_complex* ofdm_sym;
	

	//for debug
	//gr_complex data[100];
	//for (i = 0; i < 100; i++)
	//	data[i] = gr_complex(i, i);

	//end for debug
	printf("start \n");
	printf("noutput_items= %d\n", noutput_items);
	printf("sizof(complex) = %d \n", sizeof(gr_complex));
	//int noutput_intems_complex;
	//noutput_intems_complex = noutput_items / 8;

	while (nout < noutput_items) {
		in = NULL;
		incout = 0;
		switch (d_state) {
		case INIT:
			printf("INIT \n");
			d_msg = msgq() ->delete_head();
			printf("d_msg \n");
			//d_dataN = (int) (d_msg->arg1() * d_msg->arg2() );
			//d_dataN = int(d_msg->length()/sizeof(gr_complex) );
			//d_dataN = 100;
			//assert( d_dataN <= int(d_msg->length()/sizeof(gr_complex) ) );
			msg_length = d_msg->length();
			printf("msg_length = %d \n",msg_length);
			d_nsamples_written = 0;
			printf("format_param \n");
			format_param( d_MCS, msg_length,1);
			printf("Ndbps \n");
			Ndbps = (float)(Data_Nsub) * Rate_Coding * (float)((float)log(float(Data_Mod)) / (float)log(2.0));
			printf("Ndbps = %d \n", Ndbps);
			Data_Nsym = ceil((float)(8 * msg_length + n_crc_bits) / (float)Ndbps);
			Data_Nsamples = Data_Nsym * (d_Nfft + d_Ngi);
			
			ofdm_sym = (gr_complex *)(malloc( sizeof(gr_complex)*(LENGTH_HEAD + Data_Nsamples)));
			printf("format_data \n");
			
			
			printf("LENGTH_HEAD = %d, Data_Nsamples = %d \n", LENGTH_HEAD ,Data_Nsamples);
			
			
			format_data(d_MCS,1, msg_length, d_msg->msg(), &ofdm_sym[LENGTH_HEAD]);
			d_dataN = LENGTH_HEAD + Data_Nsamples;
			d_postpad = d_npost * d_block_size - (d_dataN % d_block_size);


			printf("d_dataN = %d \n", d_dataN);
			//format_data(unsigned int MCS,int Ntx, unsigned int length_msg,unsigned char *msg, gr_complex *out_data_sym);

			//gr_complex stf_matrix[160];
			
			//gr_complex ltf_matrix[160];
			//gr_complex d_param_ofdm[80];
			//copy stf
			memcpy(ofdm_sym, stf_matrix, sizeof(gr_complex)*160);
			memcpy(&ofdm_sym[160], ltf_matrix, sizeof(gr_complex)*160);
			memcpy(&ofdm_sym[320], d_param_ofdm, sizeof(gr_complex)*80);
			
			//cout << "ofdm_sym =" <<endl;
			//for(i = d_dataN - 80; i < d_dataN; i++)
			//	cout << ofdm_sym[i] << "  ";
			//cout <<endl;
			
			d_state = DATA;

		case DATA: //copy data
			printf("DATA \n");
			
			
			incout = d_dataN - d_nsamples_written;
			//in = (gr_complex *)( d_msg->msg()) + d_nsamples_written;
			in = (gr_complex *) (ofdm_sym) + d_nsamples_written;
			if (incout + nout <= noutput_items) {
				d_state = POSTPAD;
			}
			break;
		case POSTPAD:
			printf("POSTPAD \n");
			incout = d_dataN + d_postpad - d_nsamples_written;
			in = _zeropad;
			if(incout + nout <= noutput_items){
				d_state = INIT;
			}
			break;




		default:
			d_state = INIT;
			break;
		}

		// copy from input to output
		if (incout + nout > noutput_items)
			incout = noutput_items - nout;
		if ((incout > 0) && in) {
			memcpy(out + nout, in, incout * sizeof(gr_complex));
			d_nsamples_written += incout;
			nout += incout;
		}
		
		printf("d_nsamples_written= %d \n", d_nsamples_written);

		if (d_state == INIT)
			break;
	}

	//  for (int i = 0; i < noutput_items; i++){
	//    out[i] = in[i] * in[i];
	// }

	// Tell runtime system how many input items we consumed on
	// each input stream.

	//consume_each (noutput_items);

	// Tell runtime system how many output items we produced.
	return nout;
}
